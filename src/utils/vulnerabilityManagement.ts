import { Vulnerability, VulnerabilityAssessment, ScannerIntegration, PatchManagement, RiskAssessment } from '../types';
import { emailService } from './emailService';

export class VulnerabilityEngine {
  private static instance: VulnerabilityEngine;

  public static getInstance(): VulnerabilityEngine {
    if (!VulnerabilityEngine.instance) {
      VulnerabilityEngine.instance = new VulnerabilityEngine();
    }
    return VulnerabilityEngine.instance;
  }

  // CVSS-based risk calculation
  public calculateRiskScore(vulnerability: Vulnerability): number {
    let riskScore = vulnerability.cvssScore * 10; // Base score (0-100)

    // Adjust for exploitability
    const exploitabilityMultiplier = {
      'critical': 1.5,
      'high': 1.3,
      'medium': 1.1,
      'low': 1.0
    };
    riskScore *= exploitabilityMultiplier[vulnerability.exploitability];

    // Adjust for business criticality
    const businessMultiplier = {
      'critical': 1.4,
      'high': 1.2,
      'medium': 1.0,
      'low': 0.8
    };
    riskScore *= businessMultiplier[vulnerability.businessCriticality];

    // Adjust for exploit in wild
    if (vulnerability.exploitInWild) {
      riskScore *= 1.3;
    }

    // Adjust for patch availability
    if (vulnerability.patchAvailable) {
      riskScore *= 0.9; // Slightly lower risk if patch is available
    }

    // Adjust for patch complexity
    const patchComplexityMultiplier = {
      'high': 1.2, // Higher risk if patch is complex to deploy
      'medium': 1.0,
      'low': 0.9
    };
    riskScore *= patchComplexityMultiplier[vulnerability.patchComplexity];

    return Math.min(Math.round(riskScore), 100);
  }

  // Vulnerability prioritization algorithm
  public prioritizeVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
    return vulnerabilities.sort((a, b) => {
      // Primary sort: Risk score (descending)
      const riskDiff = this.calculateRiskScore(b) - this.calculateRiskScore(a);
      if (riskDiff !== 0) return riskDiff;

      // Secondary sort: CVSS score (descending)
      const cvssDiff = b.cvssScore - a.cvssScore;
      if (cvssDiff !== 0) return cvssDiff;

      // Tertiary sort: Exploit in wild (exploited first)
      if (b.exploitInWild && !a.exploitInWild) return 1;
      if (a.exploitInWild && !b.exploitInWild) return -1;

      // Quaternary sort: Business criticality
      const businessCriticalityOrder = { 'critical': 4, 'high': 3, 'medium': 2, 'low': 1 };
      const businessDiff = businessCriticalityOrder[b.businessCriticality] - businessCriticalityOrder[a.businessCriticality];
      if (businessDiff !== 0) return businessDiff;

      // Final sort: Discovery date (newer first)
      return b.discoveredDate.getTime() - a.discoveredDate.getTime();
    });
  }

  // Scanner integration simulation
  public async startAssessment(scannerId: string, targets: string[]): Promise<{
    assessmentId: string;
    status: string;
    configuration: any;
  }> {
    // Simulate scanner API call
    await new Promise(resolve => setTimeout(resolve, 1000));

    const assessmentId = `ASSESS-${Date.now()}`;
    
    console.log(`Starting vulnerability assessment with scanner ${scannerId} on targets:`, targets);

    return {
      assessmentId,
      status: 'started',
      configuration: {
        scanner: scannerId,
        targets,
        scan_policy: 'comprehensive',
        credentials_enabled: true,
        max_scan_time: 3600
      }
    };
  }

  // Nessus integration simulation
  public async integrateNessus(endpoint: string, apiKey: string): Promise<{
    success: boolean;
    scanners: any[];
    policies: any[];
  }> {
    // Simulate Nessus API integration
    await new Promise(resolve => setTimeout(resolve, 2000));

    console.log(`Integrating with Nessus at ${endpoint}`);

    return {
      success: true,
      scanners: [
        { id: 1, name: 'Nessus Scanner 1', status: 'ready', platform: 'LINUX' },
        { id: 2, name: 'Nessus Scanner 2', status: 'ready', platform: 'WINDOWS' }
      ],
      policies: [
        { id: 1, name: 'Basic Network Scan', description: 'Standard vulnerability scan' },
        { id: 2, name: 'Advanced Scan', description: 'Comprehensive scan with credentials' },
        { id: 3, name: 'Web Application Tests', description: 'OWASP Top 10 testing' }
      ]
    };
  }

  // OpenVAS integration simulation
  public async integrateOpenVAS(endpoint: string, username: string, password: string): Promise<{
    success: boolean;
    configs: any[];
    targets: any[];
  }> {
    // Simulate OpenVAS integration
    await new Promise(resolve => setTimeout(resolve, 1500));

    console.log(`Integrating with OpenVAS at ${endpoint}`);

    return {
      success: true,
      configs: [
        { id: 'full_and_fast', name: 'Full and fast', comment: 'Full and fast scan configuration' },
        { id: 'full_and_deep', name: 'Full and deep', comment: 'Full and deep scan configuration' }
      ],
      targets: [
        { id: 'target1', name: 'Internal Network', hosts: '192.168.1.0/24' },
        { id: 'target2', name: 'DMZ Servers', hosts: '10.0.1.0/24' }
      ]
    };
  }

  // Qualys integration simulation
  public async integrateQualys(apiUrl: string, username: string, password: string): Promise<{
    success: boolean;
    subscriptionInfo: any;
    scannerAppliances: any[];
  }> {
    // Simulate Qualys VMDR integration
    await new Promise(resolve => setTimeout(resolve, 1800));

    console.log(`Integrating with Qualys at ${apiUrl}`);

    return {
      success: true,
      subscriptionInfo: {
        vmdr_enabled: true,
        was_enabled: true,
        compliance_enabled: true
      },
      scannerAppliances: [
        { id: 12345, name: 'Scanner Appliance 1', status: 'ONLINE', location: 'US-East' },
        { id: 12346, name: 'Scanner Appliance 2', status: 'ONLINE', location: 'EU-West' }
      ]
    };
  }

  // Vulnerability assessment with multiple scanners
  public async performComprehensiveAssessment(targets: string[]): Promise<{
    vulnerabilities: Vulnerability[];
    scannerResults: any[];
    riskAssessment: any;
  }> {
    console.log('Performing comprehensive vulnerability assessment...');

    // Simulate multiple scanner results
    const scannerResults = await Promise.all([
      this.simulateNessusScan(targets),
      this.simulateOpenVASScan(targets),
      this.simulateQualysScan(targets)
    ]);

    // Aggregate and deduplicate vulnerabilities
    const allVulnerabilities = scannerResults.flatMap(result => result.vulnerabilities);
    const deduplicatedVulns = this.deduplicateVulnerabilities(allVulnerabilities);

    // Prioritize vulnerabilities
    const prioritizedVulns = this.prioritizeVulnerabilities(deduplicatedVulns);

    // Generate risk assessment
    const riskAssessment = this.generateRiskAssessment(prioritizedVulns);

    return {
      vulnerabilities: prioritizedVulns,
      scannerResults,
      riskAssessment
    };
  }

  // Patch management integration
  public async identifyAvailablePatches(vulnerabilities: Vulnerability[]): Promise<PatchManagement[]> {
    const patches: PatchManagement[] = [];

    for (const vuln of vulnerabilities) {
      if (vuln.patchAvailable) {
        const patch = await this.generatePatchInfo(vuln);
        patches.push(patch);
      }
    }

    return patches;
  }

  // Compliance framework mapping
  public mapToComplianceFrameworks(vulnerabilities: Vulnerability[]): {
    nist: any;
    iso27001: any;
    pci_dss: any;
    sox: any;
  } {
    const frameworks = {
      nist: { compliant: 0, non_compliant: 0, requirements: [] },
      iso27001: { compliant: 0, non_compliant: 0, requirements: [] },
      pci_dss: { compliant: 0, non_compliant: 0, requirements: [] },
      sox: { compliant: 0, non_compliant: 0, requirements: [] }
    };

    vulnerabilities.forEach(vuln => {
      // Map vulnerabilities to compliance requirements
      if (vuln.tags.includes('encryption') || vuln.tags.includes('ssl')) {
        frameworks.pci_dss.requirements.push({
          requirement: 'PCI DSS 4.1 - Use strong cryptography',
          status: vuln.status === 'patched' ? 'compliant' : 'non_compliant',
          vulnerability: vuln.id
        });
      }

      if (vuln.tags.includes('access-control') || vuln.tags.includes('authentication')) {
        frameworks.iso27001.requirements.push({
          requirement: 'ISO 27001 A.9 - Access Control',
          status: vuln.status === 'patched' ? 'compliant' : 'non_compliant',
          vulnerability: vuln.id
        });
      }

      if (vuln.businessCriticality === 'critical') {
        frameworks.sox.requirements.push({
          requirement: 'SOX Section 404 - Internal Controls',
          status: vuln.status === 'patched' ? 'compliant' : 'non_compliant',
          vulnerability: vuln.id
        });
      }

      // NIST Cybersecurity Framework mapping
      frameworks.nist.requirements.push({
        requirement: 'NIST CSF - Identify Vulnerabilities',
        status: vuln.status === 'patched' ? 'compliant' : 'non_compliant',
        vulnerability: vuln.id
      });
    });

    // Calculate compliance scores
    Object.keys(frameworks).forEach(framework => {
      const fw = frameworks[framework as keyof typeof frameworks];
      fw.compliant = fw.requirements.filter((r: any) => r.status === 'compliant').length;
      fw.non_compliant = fw.requirements.filter((r: any) => r.status === 'non_compliant').length;
    });

    return frameworks;
  }

  // Automated remediation suggestions
  public generateRemediationPlan(vulnerability: Vulnerability): {
    priority: number;
    estimatedEffort: string;
    steps: string[];
    dependencies: string[];
    riskReduction: number;
  } {
    const riskScore = this.calculateRiskScore(vulnerability);
    
    let priority = 5;
    if (riskScore >= 90) priority = 1;
    else if (riskScore >= 70) priority = 2;
    else if (riskScore >= 50) priority = 3;
    else if (riskScore >= 30) priority = 4;

    const estimatedEffort = vulnerability.patchComplexity === 'high' ? '4-8 hours' :
                           vulnerability.patchComplexity === 'medium' ? '2-4 hours' : '1-2 hours';

    const steps = vulnerability.remediationSteps || [
      'Review vulnerability details and impact',
      'Test patch in staging environment',
      'Schedule maintenance window',
      'Apply patch to production systems',
      'Verify patch installation',
      'Monitor for any issues'
    ];

    const dependencies = [];
    if (vulnerability.affectedSystems.some(sys => sys.includes('database'))) {
      dependencies.push('Database maintenance window');
    }
    if (vulnerability.affectedSystems.some(sys => sys.includes('web'))) {
      dependencies.push('Web service downtime approval');
    }

    const riskReduction = Math.min(riskScore * 0.9, 95); // Assume 90% risk reduction

    return {
      priority,
      estimatedEffort,
      steps,
      dependencies,
      riskReduction
    };
  }

  // Threat intelligence integration
  public async enrichWithThreatIntelligence(vulnerability: Vulnerability): Promise<{
    threatActors: string[];
    exploitKits: string[];
    campaigns: string[];
    iocs: string[];
  }> {
    // Simulate threat intelligence lookup
    await new Promise(resolve => setTimeout(resolve, 500));

    const threatIntel = {
      threatActors: [],
      exploitKits: [],
      campaigns: [],
      iocs: []
    };

    if (vulnerability.exploitInWild) {
      threatIntel.threatActors = ['APT29', 'Lazarus Group'];
      threatIntel.exploitKits = ['RIG EK', 'Angler EK'];
      threatIntel.campaigns = ['Operation CloudHopper', 'SolarWinds Supply Chain'];
    }

    if (vulnerability.severity === 'critical') {
      threatIntel.iocs = [
        'malicious-domain.com',
        '203.0.113.42',
        'SHA256:a1b2c3d4e5f6...'
      ];
    }

    return threatIntel;
  }

  // Private helper methods
  private async simulateNessusScan(targets: string[]): Promise<{ scanner: string; vulnerabilities: Vulnerability[] }> {
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    return {
      scanner: 'Nessus',
      vulnerabilities: [
        // Mock Nessus results would go here
      ]
    };
  }

  private async simulateOpenVASScan(targets: string[]): Promise<{ scanner: string; vulnerabilities: Vulnerability[] }> {
    await new Promise(resolve => setTimeout(resolve, 1200));
    
    return {
      scanner: 'OpenVAS',
      vulnerabilities: [
        // Mock OpenVAS results would go here
      ]
    };
  }

  private async simulateQualysScan(targets: string[]): Promise<{ scanner: string; vulnerabilities: Vulnerability[] }> {
    await new Promise(resolve => setTimeout(resolve, 800));
    
    return {
      scanner: 'Qualys',
      vulnerabilities: [
        // Mock Qualys results would go here
      ]
    };
  }

  private deduplicateVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
    const seen = new Set();
    return vulnerabilities.filter(vuln => {
      const key = vuln.cveId || `${vuln.title}-${vuln.affectedSystems.join(',')}`;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }

  private generateRiskAssessment(vulnerabilities: Vulnerability[]): any {
    const totalVulns = vulnerabilities.length;
    const criticalVulns = vulnerabilities.filter(v => v.severity === 'critical').length;
    const highVulns = vulnerabilities.filter(v => v.severity === 'high').length;
    const exploitableVulns = vulnerabilities.filter(v => v.exploitInWild).length;
    
    const overallRisk = totalVulns > 0 ? 
      ((criticalVulns * 4 + highVulns * 3 + exploitableVulns * 2) / totalVulns) * 25 : 0;

    return {
      overallRiskScore: Math.min(Math.round(overallRisk), 100),
      totalVulnerabilities: totalVulns,
      criticalCount: criticalVulns,
      highCount: highVulns,
      exploitableCount: exploitableVulns,
      recommendations: this.generateRiskRecommendations(vulnerabilities)
    };
  }

  private generateRiskRecommendations(vulnerabilities: Vulnerability[]): string[] {
    const recommendations = [];
    
    const criticalVulns = vulnerabilities.filter(v => v.severity === 'critical');
    if (criticalVulns.length > 0) {
      recommendations.push(`Immediately patch ${criticalVulns.length} critical vulnerabilities`);
    }

    const exploitableVulns = vulnerabilities.filter(v => v.exploitInWild);
    if (exploitableVulns.length > 0) {
      recommendations.push(`Priority patching for ${exploitableVulns.length} vulnerabilities with active exploits`);
    }

    const unpatchedVulns = vulnerabilities.filter(v => v.status === 'open' && v.patchAvailable);
    if (unpatchedVulns.length > 0) {
      recommendations.push(`Deploy available patches for ${unpatchedVulns.length} vulnerabilities`);
    }

    recommendations.push('Implement regular vulnerability scanning schedule');
    recommendations.push('Enhance patch management processes');
    recommendations.push('Review and update security policies');

    return recommendations;
  }

  private async generatePatchInfo(vulnerability: Vulnerability): Promise<PatchManagement> {
    return {
      id: `PATCH-${Date.now()}`,
      vulnerabilityId: vulnerability.id,
      patchId: `${vulnerability.cveId}-PATCH`,
      patchName: `Security Update for ${vulnerability.title}`,
      vendor: 'Vendor',
      releaseDate: new Date(),
      severity: vulnerability.severity,
      status: 'available',
      affectedSystems: vulnerability.affectedSystems,
      patchComplexity: vulnerability.patchComplexity,
      businessCriticality: vulnerability.businessCriticality,
      successRate: 95
    };
  }

  // Notification system for critical vulnerabilities
  public async notifyCriticalVulnerability(vulnerability: Vulnerability): Promise<void> {
    if (vulnerability.severity === 'critical' || vulnerability.exploitInWild) {
      await emailService.sendEmail({
        to: 'vanursab71@gmail.com',
        subject: `🚨 CRITICAL VULNERABILITY DETECTED - ${vulnerability.cveId}`,
        message: `
CRITICAL VULNERABILITY ALERT
============================

Vulnerability: ${vulnerability.title}
CVE ID: ${vulnerability.cveId}
CVSS Score: ${vulnerability.cvssScore}
Risk Score: ${this.calculateRiskScore(vulnerability)}

Affected Systems:
${vulnerability.affectedSystems.map(sys => `• ${sys}`).join('\n')}

Description:
${vulnerability.description}

${vulnerability.exploitInWild ? '🚨 EXPLOIT IN WILD - IMMEDIATE ACTION REQUIRED' : ''}

Remediation Steps:
${vulnerability.remediationSteps?.map((step, i) => `${i + 1}. ${step}`).join('\n') || 'See vulnerability details for remediation guidance'}

Access Vulnerability Management: https://agentphantom.ai/vulnerability-management
        `,
        type: 'alert'
      });
    }
  }
}

// Export singleton instance
export const vulnerabilityEngine = VulnerabilityEngine.getInstance();